<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: WordPress | Merge Conflicts]]></title>
  <link href="http://gboone.github.io/blog/categories/wordpress/atom.xml" rel="self"/>
  <link href="http://gboone.github.io/"/>
  <updated>2014-01-01T09:31:27-06:00</updated>
  <id>http://gboone.github.io/</id>
  <author>
    <name><![CDATA[Greg Boone]]></name>
    <email><![CDATA[boone.greg@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing Unit Tests for WordPress]]></title>
    <link href="http://gboone.github.io/blog/2014/01/01/writing-unit-tests-for-wordpress/"/>
    <updated>2014-01-01T09:30:00-06:00</updated>
    <id>http://gboone.github.io/blog/2014/01/01/writing-unit-tests-for-wordpress</id>
    <content type="html"><![CDATA[<p>In <a href="blog/2013/12/23/why-unit-testing-in-wordpress-matters/">my last post</a> I wrote about two testing libraries for WordPress and briefly discussed the difference between integration tests and unit tests. I also mentioned a concept called test driven development (TDD) and breifly explained how it might help write better code from the start. This post will expand on that and show how to write a simple WordPress plugin from a test-first approach. Since we&rsquo;re writing unit tests, we&rsquo;re going to use WP-Mock to create a test double for us and we&rsquo;ll use PHPunit for our test runner.</p>

<p>TDD starts with a problem you want to solve—the same problem your plugin wants to solve. In this case, let&rsquo;s say we have a plugin that will add some metadata to a post with the title &ldquo;Test&rdquo;. Since that&rsquo;s going to require us to mock some WordPress core functionality, <a href="https://github.com/10up/wp_mock">make sure WP-Mock is configured in your working environment</a>. We&rsquo;ll start by writing a test that verifies the metadata was attached to the post.</p>

<p>In order to write unit tests we first need to extend the base test suite:</p>

<p>```
&lt;?</p>

<pre><code>Class OurTestSuite extends extends PHPUnit_Framework_TestCase {
</code></pre>

<p>}
?>
```</p>

<p>Now that we have a class, we can call any of PHPunit&rsquo;s methods for testing including all of its assertions. Inside OurTestSuite is where we will write all our testing methods. We start with setUp and tearDown, commonly named methods that instantiate some conditions we will want for all our classes. We&rsquo;ll want to make sure our setUp and tearDown methods clean up our test environment as well as any mocks we create out of WP_Mock. So we&rsquo;ll declare:</p>

<p>```
&lt;?php</p>

<pre><code>public function setUp() {
    parent::setUp();
}

public function tearDown() {
    parent::tearDown();
}
</code></pre>

<p>?>
```</p>

<p>If we had other objects, variables, or settings we wanted available throughout the test suite, etc., we could declare those too. If you run the test now you&rsquo;ll get some output, but no tests will run because we haven&rsquo;t written any. Every test is a method within this class. Let&rsquo;s write one that will always pass just to see PHPunit give us something.</p>

<p>```php
&lt;?php</p>

<pre><code>...
public function testOneExpectsOneAdded() {
    // Arrange
    $foo = 1;

    // Act
    $bar = $foo + 1;

    // Assert
    $this-&gt;assertEquals(2, $bar, 'Variable $bar does not equal two.');
}
</code></pre>

<p>?>
```</p>

<p>If you run PHPunit on that test, you should get a dot. Congratulations!</p>

<p>Now let&rsquo;s write our test for our <code>save_meta</code> method. There are three basic sections to our test: Arrange, Act, and Assert. The first section is for all the bits our method needs for input. In our case, we&rsquo;ll need the post ID for a post called &ldquo;Test&rdquo; and a key and value pair to save as metadata. Since the ID could be any integer on a given system, we can arrange our test with any integer we like. The next piece, the key-value pair, will be set in the method, but we&rsquo;ll want to decide now what they&rsquo;ll be.</p>

<p>The &ldquo;Act&rdquo; section is where we call the method. In this case, we&rsquo;re going to call a method called <code>save_meta_data</code> out of the <code>MetaMethods</code> object. Finally, the &ldquo;Assert&rdquo; section is where we decide what the method should expect to see at the end. This section might be empty depending on whether the method under test returns an output or calls some other method. In our case, it&rsquo;s the latter. The test passes if <code>update_post_meta</code> is called exactly once. Right now our test is looking something like this:</p>

<p>```
&lt;?php
&hellip;</p>

<pre><code>public function testTestPostExpectsMetaDataSaved(){
    // Arrange
    $post_id = 42;

    // Act
    $methods = new MetaMethods();
    $methods-&gt;save_meta_data($post_id);

    // Assert
}
</code></pre>

<p>&hellip;
?>
```</p>

<p>Not a bad looking test, but we have some mocking to do. We already know we&rsquo;ll need to mock <code>update_post_meta()</code>, but we&rsquo;re also going to need <code>get_post()</code> as well. In both cases, we&rsquo;re going to make PHPunit handle calls to those methods and return what we want back. We know what to expect if we call <code>update_post_meta</code>: if all is well with our WordPress install, we expect it would add new information to the post object. So we don&rsquo;t need to verify that, all we really need to do is verify it&rsquo;s being called exactly once. So let&rsquo;s add our mocks to the &ldquo;Arrange&rdquo; section.</p>

<p>Fully mocking a function like <code>get_post()</code> uses the static method <code>wpFunction()</code> from WP_Mock. We can call it with: <code>\WP_Mock::wpFunciton()</code>. We can also pass wpFunction some parameters like &lsquo;times&rsquo;, for how many times we expect the mocked function to fire, and &lsquo;parameters&rsquo;, and &lsquo;return&rsquo;. These help us create a fully function test double of <code>get_post</code>.</p>

<p>```
&lt;?php</p>

<pre><code>...
// Arrange
$post = \WP_Mock::wpFunction('get_post')
...
</code></pre>

<p>?>
```</p>

<p>Finally, we need to address <code>update_post_meta</code>, but since we don&rsquo;t particularly care what we get back from this method, we can instead &lsquo;stub&rsquo; it. <code>WP_Mock</code> has a wrapper for <code>wpFunction</code> that make this easy, it&rsquo;s called <code>wpPassthruFunction()</code> and can take many of the same parameters, but fills in the return value for you. In our case, we want to know that update_post_meta fired once, so we can write something like:</p>

<p>```
&lt;?php</p>

<pre><code>...
// Arrange
\WP_Mock::wpPassthruFunction('update_post_meta', array('times' =&gt; 1));
...
</code></pre>

<p>?>
```</p>

<p>Now, if we run <code>phpunit</code>, we get a dot and an F, or maybe an E, since we haven&rsquo;t written any code yet. Now we can write the actual code with the following workflow:
1. Write some code
2. Run the test
3. Modify the test and code as necessary
4. Repeat 2-3 until the test passes</p>

<p>A full example of our test is below:</p>

<p>```PHP
&lt;?php
Class OurTestSuite extends extends PHPUnit_Framework_TestCase {</p>

<pre><code>public function setUp() {
    parent::setUp();
}

public function tearDown() {
    parent::tearDown();
}

public function testOneExpectsOneAdded() {
    // Arrange
    $foo = 1;

    // Act
    $bar = $foo + 1;

    // Assert
    $this-&gt;assertEquals($bar, 2, 'Variable $bar does not equal two.');
}

public function testTestPostExpectsMetaDataSaved(){
    // Arrange
    $post_id = 42;
    $post = \WP_Mock::wpFunction('get_post');
    \WP_Mock::wpPassthruFunction('update_post_meta', array('times' =&gt; 1));
    // Act
    $methods = new MetaMethods();
    $methods-&gt;save_meta_data($post_id);

    // Assert
}
</code></pre>

<p>}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Unit Testing in WordPress Matters]]></title>
    <link href="http://gboone.github.io/blog/2013/12/23/why-unit-testing-in-wordpress-matters/"/>
    <updated>2013-12-23T07:20:00-06:00</updated>
    <id>http://gboone.github.io/blog/2013/12/23/why-unit-testing-in-wordpress-matters</id>
    <content type="html"><![CDATA[<p>Testing WordPress has become a favorite topic of mine lately: moving away from hitting refresh and toward something more holistic, reliable, and automatable. I&rsquo;ve written before about <a href="http://greg.harmsboone.org/blog/2013/08/17/how-can-i-do-browser-testing-with-wordpress/">a testing method called called browser testing</a>, which verifies a webpage has some expected behavior. These kinds of tests are great but they&rsquo;re not perfect. They require a lot o dependencies and that someone else would need to verify your code. There is a better way, one that doesn&rsquo;t require any of those dependencies and verfies the code down to the exact lines you wrote—it can even be independent of WordPress. It&rsquo;s called unit testing and it will make you a better developer.</p>

<!-- more -->


<p>Unit testing is a method that reduces and tests the system down to it&rsquo;s smallest functional pieces. Each &lsquo;unit&rsquo; should be as isolated as possible from any others in the system. The test should verify only the correctness of one unit. It has many benefits for all of software development but is relatively new to WordPress. It&rsquo;s hard to say for sure why but there have been two important advancements in the area recently that will hopefully compel us WordPress devs to be more intentional about testing and verifying our code.</p>

<p>The first is the WordPress Unit Test Suite (WPUTS), detailed on the <a href="http://make.wordpress.org/core/handbook/automated-testing/">WP Core development blog</a>. This suite contains tests covering much of the core files installed with a WordPress.org site. This test suite can even be installed <a href="http://wp-cli.org/">through the fantastic WP-CLI project</a>. According to <a href="https://travis-ci.org/tierra/wordpress/jobs/15867662">a recent build on Travis</a>, 1889 tests are currently available. That build shows the output of PHP&rsquo;s test runner, <a href="http://phpunit.de">PHPunit</a> at around line 724. Each test generates either a dot for a passed test or an S, I, F or E if the test is (s)kipped, (i)gnored, (f)ails, or encounters an (e)rror. In that build you see only 2 failures and a whole bunch of skipped tests. You can also see, at line 777, that phpunit took 1:28 to run all the tests and used 141.75MB of memory. That&rsquo;s pretty good for testing an application the size of WordPress. <a href="https://github.com/wp-cli/wp-cli/wiki/Plugin-Unit-Tests">With a few simple commands in WP-CLI</a> you can install these tests on your own and extend them to cover your own plugin.</p>

<p>WPUTS was introduced sometime in late 2012 and unit testing through the core suite was recently integrated into the core development workflow. Another important project is <a href="https://github.com/10up/wp_mock/">WP-Mock</a>, a wonderful project from the folks at 10up that allows you to &lsquo;mock&rsquo; or &lsquo;stub&rsquo; only the parts of WordPress you need for each test. If you need call <code>update_post_meta()</code>, WP-Mock would allow you to just pass an integer, a key, and a value. The ideas is if your code verfies with a <a href="http://phpunit.de/manual/3.7/en/test-doubles.html">test double</a>, it will verify once it&rsquo;s hooked into the real thing.</p>

<p>There are two key differences between these two test suites: dependencies and what is tested. Compared to browser tests, both suites remove your code&rsquo;s dependency on existing content, a web server, selenium, and behave, but WPUTS still requires WordPress and a MySQL database on top of your code, PHP, and PHPunit. WP-Mock requires only the last three. This means, if you want to run your tests in a continuous integration server like Jenkins or Travis, with WP-Mock the only thing you need to set up that environment is your code, PHP, and PHPunit.</p>

<p>With WPUTS, what you are really testing is whether your code properly integrates with its dependencies, and are useful for exactly that purpose. A WordPress plugin, for example, might have integration tests written to determine whether post meta data is in fact updated when <code>update_post_meta</code> is called within one of its methods. That does not necessarily verify whether the code written is correct. True unit tests start lower, focusing on whether the code <em>you</em> wrote for <em>this</em> method generates the correct output if the dependencies behave as expected. The difference is subtle but also important.</p>

<p>With this distinction in mind, WPUTS might be better named the &lsquo;WordPress Integration Test Suite&rsquo; as it allows you to access to a full installation of WordPress and manipulation of its database. What it doesn&rsquo;t do is tell you whether you&rsquo;re manipulating that database too much. Maybe your method called <code>update_post_meta</code> twice, WPUTS will not necessarily tell you that. It will only tell you that the post was, in fact, updated. That&rsquo;s useful, but so is knowing you only did it once. Writing to a database can be expensive, doing it too many times might slow down your application.</p>

<p>Writing tests before writing code is called Test Driven Development and is a software engineering best practice. It forces you to write your test, then write code to make your test pass. In the end, this makes you a better developer because you are focused to break your problems down into smaller pieces that do more discrete testable things. How to write those tests is a subject for another blog.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How can I use feature switches in WordPress?]]></title>
    <link href="http://gboone.github.io/blog/2013/09/15/how-can-i-use-feature-switches-in-wordpress/"/>
    <updated>2013-09-15T07:54:00-05:00</updated>
    <id>http://gboone.github.io/blog/2013/09/15/how-can-i-use-feature-switches-in-wordpress</id>
    <content type="html"><![CDATA[<p>While a colleague and I were discussing the rollout of a new feature to our public facing website, he asked me if it would be possible to &ldquo;hide&rdquo; the new content behind a toggle. Effectively, he was asking me to write a <a href="http://en.wikipedia.org/wiki/Feature_toggle">feature switch</a>, a best practice of continuous integration that <a href="http://martinfowler.com/bliki/FeatureToggle.html">allows you to push some source code while hiding future features</a>. WordPress has some of this idea built into it&rsquo;s core: plugins, for example, can be activated and deactivated to turn things on and off. Within plugins and themes, options pages can be used to turn on different features. SEO plugins, for example, let users turn on and off different optimizaiton tools. Feature switches are a little different, and in our case leverage the power of Apache environment variables to show and hide different parts of our site.</p>

<!-- more -->


<h2>The problem</h2>

<p>The end goal was to take <em>n</em> posts, convert each to a new post type and then display them on a new archive template. (How we did the migration is another blog.) The problem was that while most of the code was ready, the content wasn&rsquo;t and the UAT was in progress. In order to run the content migration script, the bulk of the source code had to be live on at least our staging environment, but until everything else was finished, the archive needed to stay hidden.</p>

<p>Post type and taxonomy registration was done through another plugin, and turning that off was not an option, but we could change the way we registered <em>this</em> particular post type by manipulating some of the arguments passed to <code>register_post_type()</code>.</p>

<p>Typically, if you&rsquo;re going to register a post type you want to use and see it right away. You might even use a generator to do it for you:</p>

<p>``` php
add_action( &lsquo;init&rsquo;, &lsquo;register_cpt_post_type&rsquo; );</p>

<p>function register_cpt_post_type() {</p>

<pre><code>$labels = array( 
    'name' =&gt; _x( 'Post type', 'post_type' ),
    'singular_name' =&gt; _x( 'Post type', 'post_type' ),
    'add_new' =&gt; _x( 'Add New', 'post_type' ),
    'add_new_item' =&gt; _x( 'Add New Post type', 'post_type' ),
    'edit_item' =&gt; _x( 'Edit Post type', 'post_type' ),
    'new_item' =&gt; _x( 'New Post type', 'post_type' ),
    'view_item' =&gt; _x( 'View Post type', 'post_type' ),
    'search_items' =&gt; _x( 'Search Post type', 'post_type' ),
    'not_found' =&gt; _x( 'No post type found', 'post_type' ),
    'not_found_in_trash' =&gt; _x( 'No post type found in Trash', 'post_type' ),
    'parent_item_colon' =&gt; _x( 'Parent Post type:', 'post_type' ),
    'menu_name' =&gt; _x( 'Post type', 'post_type' ),
);

$args = array( 
    'labels' =&gt; $labels,
    'hierarchical' =&gt; true,
    'supports' =&gt; array( 'title', 'editor' ),
    'public' =&gt; true,
    'show_ui' =&gt; true,
    'show_in_menu' =&gt; true,
    'show_in_nav_menus' =&gt; true,
    'publicly_queryable' =&gt; true,
    'exclude_from_search' =&gt; false,
    'has_archive' =&gt; true,
    'query_var' =&gt; true,
    'can_export' =&gt; true,
    'rewrite' =&gt; true,
    'capability_type' =&gt; 'post'
);

register_post_type( 'post_type', $args );
</code></pre>

<p>}
```</p>

<p>Zoom in on two of the <code>$args</code>: <code>public</code> and <code>has_archive</code>. The first turns the post type on in the backend and lets you create new posts of that type. The second controls whether typing <code>http://your.url/your_post_type</code> will lead to an archive or something else. In our case, we wanted <code>/your_post_type</code> to hit a WordPress page called <code>your_post_type</code> (the default behavior) until we were ready to launch the new feature at which point it should hit the post type archive. Remember, we don&rsquo;t want to launch until all the content is migrated to the new post type, so it was critical that we have it accessible on the back-end (<code>public =&gt; true</code>) but it&rsquo;s archive remain hidden on the front (<code>with_archive =&gt; false</code>).</p>

<h3>Possible solutions</h3>

<p>We could have stored the switch in an option, but that would require hitting or caching a database value for every page load. That&rsquo;s not terribly expensive, but putting the switch at the application level is faster, more elegant, and reserves the <code>wp_options</code> table for storing our actual options. So originally we tried locating the switch as a variable in the plugin registration function. Since it was hooked to <code>plugins_loaded</code> it would fire, before post type registration, on every page load. That was less than elegant, however, because it effectively meant we had to maintain different branches of code for each environment, which could get confusing and/or messy.</p>

<h2>Enter SetEnv and get_env();</h2>

<p>PHP&rsquo;s <code>get_env()</code> function is a simple one that fetches a specified <a href="http://en.wikipedia.org/wiki/Environment_variable">environment variable</a> from the server configuration. Environment variables do all kinds of cool things, and if you set one in your Apache configuration, you can wrap new features in conditionals based on whether and to what value it is set.</p>

<p>First, write some PHP code like this:</p>

<p>``` php
$env = get_env(VARIABLE_NAME);
if ( isset($env) ) {</p>

<pre><code>// do stuff
</code></pre>

<p>} else {</p>

<pre><code>// do other stuff
</code></pre>

<p>}
```</p>

<p>Then, when you&rsquo;re  ready to toggle the feature, add a line like this to your <a href="http://httpd.apache.org/docs/2.0/mod/mod_env.html#setenv">Apache configuration</a>: <code>SetEnv VARIABLE_NAME value</code> where VARIABLE_NAME matches the <code>get_env()</code> parameter from above. Finally, restart Apache to trigger the change. To turn it off again, remove the <code>SetEnv</code> line and restart Apache.</p>

<p>In this example, it doesn&rsquo;t matter what the variable is set to; as long as it exists, the <code>if</code> condition is true. Now you have an effective feature switch that doesn&rsquo;t depend on your source code. You could even play around with setting multiple conditions using <code>elseif</code>. And that&rsquo;s how you use feature switches in WordPress.</p>

<p><a href="https://news.ycombinator.com/item?id=6389250">Discuss on Hacker News.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A week into Octopress]]></title>
    <link href="http://gboone.github.io/blog/2013/08/03/a-week-into-octopress/"/>
    <updated>2013-08-03T11:39:00-05:00</updated>
    <id>http://gboone.github.io/blog/2013/08/03/a-week-into-octopress</id>
    <content type="html"><![CDATA[<p>About a week ago I successfully migrated some of my posts from <a href="http://harmsboone.org">harmsboone.org</a> to this blog, I also wrote a post about <a href="http://greg.harmsboone.org/blog/2013/07/28/what-i-learned-about-git-this-week/">some things I learned about git that week</a>. WordPress is great. I wouldn&rsquo;t recommend it (and I almost always do) if it weren&rsquo;t. For someone who wants to spin up a blog and maybe some day more in a pinch, WordPress is the go-to platform. In fact, the rest of harmsboone.org still runs it. Earlier this year, though, Danielle and I started talking about ditching the one-blog-for-both solution. When we were both living and teaching abroad sharing one blog made sense but now with the both of us starting different careers, we have different things to say.</p>

<p>We decided to keep HarmsBoone.org as an archive of the last four years and also create new blogs for the both of us. Since I was starting from scratch anyway, might as well strike out with something new.</p>

<!-- more -->


<p>Octopress required a different way of thinking. It&rsquo;s a static file generator, not a server-database system. I knew that. I even knew I wanted to host it on GitHub but nevertheless, for whatever reason, my first step was to fire up a server for greg.harmsboone.org and installing octopress in parallel on the server and my local machine, just like I would if I were setting up WordPress. Wrong. When I stopped overcomplicating and <a href="http://octopress.org/docs">followed the directions</a>, everything fell right into palce. (For anyone trying to launch their Octopress site, it&rsquo;s a lot easier when you <code>rake new_post[]</code> or <code>rake new_page[]</code> before trying to deploy.)</p>

<h2>Things to like:</h2>

<h4>1. Simplicty.</h4>

<p>I love how clean and simple the Octopress interface is. There&rsquo;s no menu-laden backend to interface with, no menus to customize, or sidebars to fiddle with. All of that lives in HTML files that live on my machine and backed up on github.</p>

<h4>2. Backed up, version controlled</h4>

<p>Since the site is hosted on GitHub, I&rsquo;m forced to use version control on my posts, pages, and template files. This has the added bonus of all my posts being backed up as soon as their published. With WordPress, they were trapped on a MySQL database at Dreamhost. Sure I could have shelled out for <a href="">RAMP</a>, <a href="">Backup Buddy</a> or <a href="">VaultPress</a>, but one of those would just be another plugin I&rsquo;d have to deal with and would still not version control my blog.</p>

<h4>3. <code>rake preview</code></h4>

<p>What? No MAMP/XAMPP/AMPPS? Done. Over. Next.</p>

<h3>Things I miss:</h3>

<p>This is not to say Octopress land is all roses and unicorns. There are some major disadvantages to the new frontier.</p>

<h4>1. The web interface</h4>

<p>WP-Admin has the distinct advantage of being a web-based content editing interface that lives in the same place where the content is hosted. It also generates those posts automatically. With Octopress, I have to <code>rake deploy</code> to publish. That&rsquo;s less convenient.</p>

<h4>2. Mobile Apps</h4>

<p>With little exception, I&rsquo;ve been laptop-free since we got back from Hungary. The iPad did just about everything I needed to do away from my desktop while I was in grad school. Tablets are great and have the added benefit of being able to stay in my backpack in security lines (at least in the US).</p>

<p>The WordPress mobile app is great and updating blogs from it is really. Octopress isn&rsquo;t quite there. If I wanted to blog from a tablet, <a href="http://www.candlerblog.com/2012/04/01/remote-octopress-workflow/">I&rsquo;d have to have a remote server syncing and auto-deploying from dropbox or GitHub</a>. I&rsquo;ll probably end up brigning a laptop, at least until <code>rake watch --autodeploy</code> becomes a thing.</p>

<h4>3. For Hackers Only</h4>

<p>One appealing thing about working in WordPress was that everything was on the same system. Octopress bring the terminal-centric, that rules out a lot of possible users who are not also developers. People who don&rsquo;t have patience to learn Markdown or git are out. WordPress, to some extent, just works. It&rsquo;s intuitive, has a UI, and requires very little maintenance beyond an occasional software update.</p>
]]></content>
  </entry>
  
</feed>
