<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: WordPress, | Merge Conflicts]]></title>
  <link href="http://gboone.github.io/blog/categories/wordpress/atom.xml" rel="self"/>
  <link href="http://gboone.github.io/"/>
  <updated>2013-09-15T10:43:07-04:00</updated>
  <id>http://gboone.github.io/</id>
  <author>
    <name><![CDATA[Greg Boone]]></name>
    <email><![CDATA[boone.greg@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How can I use feature switches in WordPress?]]></title>
    <link href="http://gboone.github.io/blog/2013/09/15/how-can-i-use-feature-switches-in-wordpress/"/>
    <updated>2013-09-15T07:54:00-04:00</updated>
    <id>http://gboone.github.io/blog/2013/09/15/how-can-i-use-feature-switches-in-wordpress</id>
    <content type="html"><![CDATA[<p>While a colleague and I were discussing the rollout of a new feature to our public facing website, he asked me if it would be possible to &ldquo;hide&rdquo; the new content behind a toggle. Effectively, he was asking me to write a <a href="http://en.wikipedia.org/wiki/Feature_toggle">feature switch</a>, a best practice of continuous integration that <a href="http://martinfowler.com/bliki/FeatureToggle.html">allows you to push some source code while hiding future features not yet ready</a>. WordPress has some of this idea built into it&rsquo;s core: plugins, for example, can be activated and deactivated to turn things on and off. Within plugins and themes, options pages can be used to turn on different features. SEO plugins do this quite a bit, turning on different SEO features depending on whether the user <em>wants</em> them. Feature switches are a bit different, and in our case leverage the power of Apache environment variables to show and hide developing features.</p>

<!-- more -->


<h2>The problem</h2>

<p>The problem we faced was that we had <em>n</em> posts that we needed to first convert to a new post type and then present in a radically different way. The UI was getting a major refresh and we were sorting and storing these posts in a more logical way. The problem was that while most of the code was ready, it had to go through the normal UAT that everything else did and in order to run the content migration script, the bulk of the source code had to be live on at least our staging environment, but none of the new features should be exposed to the world until all of this was complete.</p>

<p>Our post type and taxonomy registration was done through a plugin we built for an earlier project, so turning that off was not an option, but we could change the way we registered <em>this</em> new post type by manipulating some of the parameters in <code>register_post_type();</code>.</p>

<p>Typically, if you&rsquo;re going to register a post type you want to use and see it right away. You might even use a generator to do it for you:</p>

<p>``` php
add_action( &lsquo;init&rsquo;, &lsquo;register_cpt_post_type&rsquo; );</p>

<p>function register_cpt_post_type() {</p>

<pre><code>$labels = array( 
    'name' =&gt; _x( 'Post type', 'post_type' ),
    'singular_name' =&gt; _x( 'Post type', 'post_type' ),
    'add_new' =&gt; _x( 'Add New', 'post_type' ),
    'add_new_item' =&gt; _x( 'Add New Post type', 'post_type' ),
    'edit_item' =&gt; _x( 'Edit Post type', 'post_type' ),
    'new_item' =&gt; _x( 'New Post type', 'post_type' ),
    'view_item' =&gt; _x( 'View Post type', 'post_type' ),
    'search_items' =&gt; _x( 'Search Post type', 'post_type' ),
    'not_found' =&gt; _x( 'No post type found', 'post_type' ),
    'not_found_in_trash' =&gt; _x( 'No post type found in Trash', 'post_type' ),
    'parent_item_colon' =&gt; _x( 'Parent Post type:', 'post_type' ),
    'menu_name' =&gt; _x( 'Post type', 'post_type' ),
);

$args = array( 
    'labels' =&gt; $labels,
    'hierarchical' =&gt; true,
    'supports' =&gt; array( 'title', 'editor' ),
    'public' =&gt; true,
    'show_ui' =&gt; true,
    'show_in_menu' =&gt; true,
    'show_in_nav_menus' =&gt; true,
    'publicly_queryable' =&gt; true,
    'exclude_from_search' =&gt; false,
    'has_archive' =&gt; true,
    'query_var' =&gt; true,
    'can_export' =&gt; true,
    'rewrite' =&gt; true,
    'capability_type' =&gt; 'post'
);

register_post_type( 'post_type', $args );
</code></pre>

<p>}
```</p>

<p>Zoom in on two of the <code>$args</code>: <code>public</code> and <code>has_archive</code>. The first turns the post type on in the backend and lets you create new posts of that type. The second controls whether typing <code>http://your.url/your_post_type</code> will lead to an archive or something else. In our case, we wanted <code>/your_post_type</code> to hit a WordPress page called <code>your_post_type</code> (the default behavior) until we were ready to launch the new feature at which point it should hit the post type archive. Remember, we don&rsquo;t want to launch until all the content is migrated to the new post type, so it was critical that we have it accessible on the back-end (<code>public =&gt; true</code>) but it&rsquo;s archive remain hidden on the front (<code>with_archive =&gt; false</code>).</p>

<h3>Possible solutions</h3>

<p>We could have stored the switch in an option, but that would require hitting or caching a database value for every page load. That&rsquo;s not terribly expensive, but putting the switch at the application level is faster, more elegant, and reserves the <code>wp_options</code> table for storing our actual options. So originally we tried locating the switch as a variable in the plugin registration function. Since it was hooked to <code>plugins_loaded</code> it would fire, before post type registration, on every page load. That was less than elegant, however, because it effectively meant we had to maintain different branches of code for each environment, which could get confusing and/or messy.</p>

<h2>Enter <code>get_env();</code></h2>

<p>PHP&rsquo;s <code>get_env()</code> function is a simple one that fetches a specified <a href="http://en.wikipedia.org/wiki/Environment_variable">environment variable</a> from the server configuration. Environment variables do all kinds of cool things, and if you set one in your Apache configuration, you can wrap new features in conditionals based on whether and to what value it is set.</p>

<p>First, write some PHP code like this:</p>

<p>``` php
$env = get_env(VARIABLE_NAME);
if ( isset($env) ) {</p>

<pre><code>// do stuff
</code></pre>

<p>} else {</p>

<pre><code>// do other stuff
</code></pre>

<p>}
```</p>

<p>Then, when you&rsquo;re  ready to toggle the feature, add a line like this to your apache configuration: <code>[SetEnv](http://httpd.apache.org/docs/2.0/mod/mod_env.html#setenv) VARIABLE_NAME=value</code> where VARIABLE_NAME matches the <code>get_env()</code> parameter from above. Finally, restart Apache to trigger the change. To turn it off again, remove the <code>SetEnv</code> line and restart Apache.</p>

<p>In this example, it doesn&rsquo;t matter what the variable is set to, as long as it exists, the <code>if</code> condition is true. Now you have an effective feature switch that doesn&rsquo;t depend on your source code.</p>
]]></content>
  </entry>
  
</feed>
